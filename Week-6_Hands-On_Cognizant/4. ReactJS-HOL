npx create-react-app blogapp
import React from 'react';

class Post extends React.Component {
  render() {
    return (
      <div style={{ border: "1px solid #ccc", padding: "10px", margin: "10px" }}>
        <h3>{this.props.title}</h3>
        <p>{this.props.body}</p>
      </div>
    );
  }
}

export default Post;
import React from 'react';
import Post from './Post';

class Posts extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      posts: [],
      hasError: false
    };
  }

  loadPosts() {
    fetch('https://jsonplaceholder.typicode.com/posts')
      .then(response => response.json())
      .then(data => this.setState({ posts: data }))
      .catch(error => {
        console.error("Error fetching posts:", error);
        this.setState({ hasError: true });
      });
  }

  componentDidMount() {
    this.loadPosts();
  }

  componentDidCatch(error, info) {
    alert("An error occurred in the component.");
    console.log("Error:", error);
    console.log("Info:", info);
  }

  render() {
    return (
      <div>
        <h2>Blog Posts</h2>
        {this.state.posts.map(post => (
          <Post key={post.id} title={post.title} body={post.body} />
        ))}
      </div>
    );
  }
}

export default Posts;
import React from 'react';
import Posts from './Posts';

function App() {
  return (
    <div className="App">
      <h1>Welcome to BlogApp</h1>
      <Posts />
    </div>
  );
}

export default App;
cd blogapp
npm start
http://localhost:3000

1. Explain the need and benefits of the component life cycle
React components go through different stages during their life — like creation, updating, and removal. These stages are called the component life cycle.
The life cycle is important because it allows you to run specific code at specific times, like when a component is added to the page or when data is fetched.

Benefits:
Helps manage data loading
Makes it easy to clean up resources like timers or event listeners
Useful for error handling and debugging
Improves performance by controlling re-renders

2. Identify various life cycle hook methods
Here are some important life cycle methods in class components:
constructor() – Initializes the component and sets the initial state
render() – Returns the JSX to be displayed
componntDidMount() – Called once after the component is mounted; good for API calls
compoentDidUpdate() – Called after every update; used to react to changes in props or state
componentWillUnmount() – Called before the component is removed from the DOM; good for cleanup
componentDidCatch() – Used to handle errors in the component tree

3. List the sequence of steps in rendering a component
The basic sequence in class components is:
constructor() – Component is created and initialized
render() – JSX is returned and UI is built
componentDidMount() – Called after the component is displayed on screen
(optional) – If state or props change, then:
shouldComponentUpdate() (optional)
render() (re-renders updated UI)
componentDidUpdate() is called
componentWillUnmount() – Called before component is removed
componentDidCatch() – Handles any errors that happen inside the component


